<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Pebble SDK: Graphics Types</title>
  <link href='bootstrap.css' media='screen' rel='stylesheet' type='text/css' />
  <link href='pebble-developer.css' media='screen' rel='stylesheet' type='text/css' />
  <link href="tabs.css" rel="stylesheet" type="text/css"/>
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="dynsections.js"></script>
  <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
  <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
  <link href="stylesheet.css" rel="stylesheet" type="text/css" />
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-30638158-4']);
    _gaq.push(['_trackPageview']);
    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
</head>
<body>
  <div id="top" ><!-- do not remove this div, it is closed by doxygen! -->
    <div class="navbar navbar-inverse ">
      <div class="navbar-inner">
        <div class="container">
          <button type="button" class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <div class="nav-collapse collapse">
            <ul class="nav">
              <li><a class="first" href="#"><span></span></a></li>
              <li><a href="http://developer.getpebble.com/">Develop for Pebble</a></li>
            </ul>
            <ul class="nav pull-right">
              <li class="doc-nav-searchbox">        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</li>
              <li><a href="http://forums.getpebble.com/">Forum</a></li>
              <li><a href="http://developer.getpebble.com/2/api-reference/modules.html">API Documentation</a></li>
              <li><a href="http://developer.getpebble.com/2/">Guides</a></li>
              <li><a href="http://developer.getpebble.com/blog/">Developer Blog</a></li>
            </ul>
          </div>
        </div>
      </div>
    </div>
<!-- Generated by Doxygen 1.8.4 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group___graphics_types.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Groups</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a>  </div>
  <div class="headertitle">
<div class="title">Graphics Types<div class="ingroups"><a class="el" href="group___graphics.html">Graphics</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Basic graphics types (point, rect, size, color, bitmaps, etc.) and utility functions. </p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group___color_definitions"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___color_definitions.html">Color Definitions</a></td></tr>
<tr class="memdesc:group___color_definitions"><td class="mdescLeft">&#160;</td><td class="mdescRight">A list of all of the named colors available with links to the color map on the Pebble Developer website. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga5d86515990747e47a76c0a16ed6b2850"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GBitmap* gbitmap_create_as_sub_bitmap </td>
          <td>(</td>
          <td class="paramtype">const GBitmap *&#160;</td>
          <td class="paramname"><em>base_bitmap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___graphics_types.html#struct_g_rect">GRect</a>&#160;</td>
          <td class="paramname"><em>sub_rect</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new GBitmap on the heap as a sub-bitmap of a 'base' GBitmap, using a <a class="el" href="group___graphics_types.html#struct_g_rect" title="Represents a rectangle and defining it using the origin of the upper-lefthand corner and its size...">GRect</a> to indicate what portion of the base to use. The sub-bitmap will just reference the image data and palette of the base bitmap. No deep-copying occurs as a result of calling this function, thus the caller is responsible for making sure the base bitmap and palette will remain available when using the sub-bitmap. Note that you should not destroy the parent bitmap until the sub_bitmap has been destroyed. The resulting GBitmap must be destroyed using <a class="el" href="group___graphics_types.html#ga0b0540c1de9ecadbef44e7d87e05ca92">gbitmap_destroy()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">base_bitmap</td><td>The bitmap that the sub-bitmap of which the image data will be used by the sub-bitmap </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">sub_rect</td><td>The rectangle within the image data of the base bitmap. The bounds of the base bitmap will be used to clip <code>sub_rect</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the GBitmap. <code>NULL</code> if the GBitmap could not be created </dd></dl>

</div>
</div>
<a class="anchor" id="gaa300cd8eadcfe00bd05c3b1eebf22687"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GBitmap* gbitmap_create_blank </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___graphics_types.html#struct_g_size">GSize</a>&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___graphics_types.html#ga5c29b6b52478182a01ec4863de80ebfa">GBitmapFormat</a>&#160;</td>
          <td class="paramname"><em>format</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new blank GBitmap on the heap initialized to zeroes. In the case that the format indicates a palettized bitmap, a palette of appropriate size will also be allocated on the heap. The resulting GBitmap must be destroyed using <a class="el" href="group___graphics_types.html#ga0b0540c1de9ecadbef44e7d87e05ca92">gbitmap_destroy()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The Pebble image dimensions as a <a class="el" href="group___graphics_types.html#struct_g_size">GSize</a>. </td></tr>
    <tr><td class="paramname">format</td><td>The <a class="el" href="group___graphics_types.html#ga5c29b6b52478182a01ec4863de80ebfa">GBitmapFormat</a> the created image should be in. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the GBitmap. <code>NULL</code> if the GBitmap could not be created </dd></dl>

</div>
</div>
<a class="anchor" id="gaaecee8293ad845287bd4e1d90bc55782"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GBitmap* gbitmap_create_blank_with_palette </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___graphics_types.html#struct_g_size">GSize</a>&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___graphics_types.html#ga5c29b6b52478182a01ec4863de80ebfa">GBitmapFormat</a>&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GColor *&#160;</td>
          <td class="paramname"><em>palette</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>free_on_destroy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new blank GBitmap on the heap, initialized to zeroes, and assigns it the given palette. No deep-copying of the palette occurs, so the caller is responsible for making sure the palette remains available when using the resulting bitmap. Management of that memory can be handed off to the system with the free_on_destroy argument. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The Pebble image dimensions as a <a class="el" href="group___graphics_types.html#struct_g_size">GSize</a>. </td></tr>
    <tr><td class="paramname">format</td><td>the <a class="el" href="group___graphics_types.html#ga5c29b6b52478182a01ec4863de80ebfa">GBitmapFormat</a> the created image and palette should be in. </td></tr>
    <tr><td class="paramname">palette</td><td>a pointer to a palette that is to be used for this GBitmap. The palette should be large enough to hold enough colors for the specified format. For example, GBitmapFormat2BitPalette should have 4 colors, since 2^2 = 4. </td></tr>
    <tr><td class="paramname">free_on_destroy</td><td>Set whether the palette data should be freed along with the bitmap data when the GBitmap is destroyed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A Pointer to the GBitmap. <code>NULL</code> if the GBitmap could not be created. </dd></dl>

</div>
</div>
<a class="anchor" id="ga5ab3b20588760558364911972b7db142"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GBitmap* gbitmap_create_from_png_data </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>png_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___standard_memory.html#ga7b60c5629e55e8ec87a4547dd4abced4">size_t</a>&#160;</td>
          <td class="paramname"><em>png_data_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The resulting GBitmap must be destroyed using <a class="el" href="group___graphics_types.html#ga0b0540c1de9ecadbef44e7d87e05ca92">gbitmap_destroy()</a>. The developer is responsible for freeing png_data following this call. </p>
<dl class="section note"><dt>Note</dt><dd>PNG decoding currently supports 1,2,4 and 8 bit palettized and grayscale images. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">png_data</td><td>PNG image data. </td></tr>
    <tr><td class="paramname">png_data_size</td><td>PNG image size in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the GBitmap. <code>NULL</code> if the GBitmap could not be created </dd></dl>

</div>
</div>
<a class="anchor" id="ga0c01fd1816c6c0fde05310141f293cc5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GBitmap* gbitmap_create_with_data </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new GBitmap on the heap initialized with the provided Pebble image data. </p>
<p>The resulting GBitmap must be destroyed using <a class="el" href="group___graphics_types.html#ga0b0540c1de9ecadbef44e7d87e05ca92">gbitmap_destroy()</a> but the image data will not be freed automatically. The developer is responsible for keeping the image data in memory as long as the bitmap is used and releasing it after the bitmap is destroyed. </p>
<dl class="section note"><dt>Note</dt><dd>One way to generate Pebble image data is to use bitmapgen.py in the Pebble SDK to generate a .pbi file. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The Pebble image data. Must not be NULL. The function assumes the data to be correct; there are no sanity checks performed on the data. The data will not be copied and the pointer must remain valid for the lifetime of this GBitmap. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the GBitmap. <code>NULL</code> if the GBitmap could not be created </dd></dl>

</div>
</div>
<a class="anchor" id="gae1c7c90641f5138b5f36f9334d52085a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GBitmap* gbitmap_create_with_resource </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___standard_c.html#gad53b3f685c3f3153f35ec87ea6f349d1">uint32_t</a>&#160;</td>
          <td class="paramname"><em>resource_id</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new GBitmap on the heap using a Pebble image file stored as a resource. The resulting GBitmap must be destroyed using <a class="el" href="group___graphics_types.html#ga0b0540c1de9ecadbef44e7d87e05ca92">gbitmap_destroy()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">resource_id</td><td>The ID of the bitmap resource to load </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the GBitmap. <code>NULL</code> if the GBitmap could not be created </dd></dl>

</div>
</div>
<a class="anchor" id="ga0b0540c1de9ecadbef44e7d87e05ca92"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gbitmap_destroy </td>
          <td>(</td>
          <td class="paramtype">GBitmap *&#160;</td>
          <td class="paramname"><em>bitmap</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy a GBitmap. This must be called for every bitmap that's been created with gbitmap_create_*. </p>
<p>This function will also free the memory of the bitmap data (bitmap-&gt;addr) if the bitmap was created with <a class="el" href="group___graphics_types.html#gaa300cd8eadcfe00bd05c3b1eebf22687">gbitmap_create_blank()</a> or <a class="el" href="group___graphics_types.html#gae1c7c90641f5138b5f36f9334d52085a">gbitmap_create_with_resource()</a>.</p>
<p>If the GBitmap was created with <a class="el" href="group___graphics_types.html#ga0c01fd1816c6c0fde05310141f293cc5">gbitmap_create_with_data()</a>, you must release the memory after calling <a class="el" href="group___graphics_types.html#ga0b0540c1de9ecadbef44e7d87e05ca92" title="Destroy a GBitmap. This must be called for every bitmap that&#39;s been created with gbitmap_create_*. ">gbitmap_destroy()</a>. </p>

</div>
</div>
<a class="anchor" id="gafce95e410fee76c66526f167c8415f3f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___graphics_types.html#struct_g_rect">GRect</a> gbitmap_get_bounds </td>
          <td>(</td>
          <td class="paramtype">const GBitmap *&#160;</td>
          <td class="paramname"><em>bitmap</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group___graphics_types.html#ga3ef230f384923b9d02b735ac7c0aa7e4">gbitmap_set_bounds</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga032629d36d12d13aadfd5176fd0463c8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___standard_c.html#gabf6633e0fef9023e8a1e8d727f4023e1">uint16_t</a> gbitmap_get_bytes_per_row </td>
          <td>(</td>
          <td class="paramtype">const GBitmap *&#160;</td>
          <td class="paramname"><em>bitmap</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of bytes per row in the bitmap data for the given GBitmap. This can be used as a safe way of iterating over the rows in the bitmap, since bytes per row should be set according to format. </p>

</div>
</div>
<a class="anchor" id="gacb0f0a071e491d8e96be6bc8ccb921cf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t* gbitmap_get_data </td>
          <td>(</td>
          <td class="paramtype">const GBitmap *&#160;</td>
          <td class="paramname"><em>bitmap</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a pointer to the data section of the given GBitmap. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group___graphics_types.html#ga032629d36d12d13aadfd5176fd0463c8" title="Get the number of bytes per row in the bitmap data for the given GBitmap. This can be used as a safe ...">gbitmap_get_bytes_per_row</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga3c8c92415f93744d2a5aec9cb40194c8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___graphics_types.html#ga5c29b6b52478182a01ec4863de80ebfa">GBitmapFormat</a> gbitmap_get_format </td>
          <td>(</td>
          <td class="paramtype">const GBitmap *&#160;</td>
          <td class="paramname"><em>bitmap</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The format of the given GBitmap. </dd></dl>

</div>
</div>
<a class="anchor" id="ga89a2945409ae7b2485a1b509dfc1333e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GColor* gbitmap_get_palette </td>
          <td>(</td>
          <td class="paramtype">const GBitmap *&#160;</td>
          <td class="paramname"><em>bitmap</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group___graphics_types.html#ga89a2945409ae7b2485a1b509dfc1333e">gbitmap_get_palette</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga3dba771fd88df27504b17e4bc2b08d64"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GBitmapSequence* gbitmap_sequence_create_with_resource </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___standard_c.html#gad53b3f685c3f3153f35ec87ea6f349d1">uint32_t</a>&#160;</td>
          <td class="paramname"><em>resource_id</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loading the apng from resource, initializes header, duration and frame count only (IHDR, acTL, alTL chunks) </p>

</div>
</div>
<a class="anchor" id="ga80e569d755b657753e3508db7f3738ff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gbitmap_sequence_destroy </td>
          <td>(</td>
          <td class="paramtype">GBitmapSequence *&#160;</td>
          <td class="paramname"><em>bitmap_sequence</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deletes the GBitmapSequence structure and frees any allocated memory/decoder_data. </p>

</div>
</div>
<a class="anchor" id="ga0f7029b68fc5f0b6a8869a0aa7717fdc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool gbitmap_sequence_update_bitmap_next_frame </td>
          <td>(</td>
          <td class="paramtype">GBitmapSequence *&#160;</td>
          <td class="paramname"><em>bitmap_sequence</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GBitmap *&#160;</td>
          <td class="paramname"><em>bitmap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___standard_c.html#gad53b3f685c3f3153f35ec87ea6f349d1">uint32_t</a> *&#160;</td>
          <td class="paramname"><em>delay_ms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates the contents of the bitmap sequence to the next frame and returns the delay in milliseconds until the next frame. </p>

</div>
</div>
<a class="anchor" id="ga3ef230f384923b9d02b735ac7c0aa7e4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gbitmap_set_bounds </td>
          <td>(</td>
          <td class="paramtype">GBitmap *&#160;</td>
          <td class="paramname"><em>bitmap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___graphics_types.html#struct_g_rect">GRect</a>&#160;</td>
          <td class="paramname"><em>bounds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the bounds of the given GBitmap. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group___graphics_types.html#gafce95e410fee76c66526f167c8415f3f">gbitmap_get_bounds</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga64f2a0d2488f425a710864e127d1d327"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gbitmap_set_data </td>
          <td>(</td>
          <td class="paramtype">GBitmap *&#160;</td>
          <td class="paramname"><em>bitmap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___graphics_types.html#ga5c29b6b52478182a01ec4863de80ebfa">GBitmapFormat</a>&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___standard_c.html#gabf6633e0fef9023e8a1e8d727f4023e1">uint16_t</a>&#160;</td>
          <td class="paramname"><em>row_size_bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>free_on_destroy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the bitmap data for the given GBitmap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bitmap</td><td>A pointer to the GBitmap to set data to </td></tr>
    <tr><td class="paramname">data</td><td>A pointer to the bitmap data </td></tr>
    <tr><td class="paramname">format</td><td>the format of the bitmap data. If this is a palettized format, make sure that there is an accompanying call to <a class="el" href="group___graphics_types.html#ga4450b2f567703a3e27bcbb51117aa087">gbitmap_set_palette</a>. </td></tr>
    <tr><td class="paramname">row_size_bytes</td><td>How many bytes a single row takes. For example, bitmap data of format GBitmapFormat1Bit must have a row size as a multiple of 4 bytes. </td></tr>
    <tr><td class="paramname">free_on_destroy</td><td>Set whether the data should be freed when the GBitmap is destroyed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group___graphics_types.html#ga0b0540c1de9ecadbef44e7d87e05ca92">gbitmap_destroy</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga4450b2f567703a3e27bcbb51117aa087"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gbitmap_set_palette </td>
          <td>(</td>
          <td class="paramtype">GBitmap *&#160;</td>
          <td class="paramname"><em>bitmap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GColor *&#160;</td>
          <td class="paramname"><em>palette</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>free_on_destroy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the palette for the given GBitmap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bitmap</td><td>A pointer to the GBitmap to set the palette to </td></tr>
    <tr><td class="paramname">palette</td><td>The palette to be used. Make sure that the palette is large enough for the bitmap's format. </td></tr>
    <tr><td class="paramname">free_on_destroy</td><td>Set whether the palette data should be freed when the GBitmap is destroyed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group___graphics_types.html#ga3c8c92415f93744d2a5aec9cb40194c8">gbitmap_get_format</a> </dd>
<dd>
<a class="el" href="group___graphics_types.html#ga0b0540c1de9ecadbef44e7d87e05ca92">gbitmap_destroy</a> </dd>
<dd>
<a class="el" href="group___graphics_types.html#ga4450b2f567703a3e27bcbb51117aa087">gbitmap_set_palette</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gae107accf4d3200daccc6ef46001f0c3f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool GColorEq </td>
          <td>(</td>
          <td class="paramtype">GColor8&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GColor8&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Comparison function for GColors. </p>

</div>
</div>
<a class="anchor" id="ga55941ba733d6b685ba3fcd316ce12af0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool gpoint_equal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___graphics_types.html#struct_g_point">GPoint</a> *const&#160;</td>
          <td class="paramname"><em>point_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___graphics_types.html#struct_g_point">GPoint</a> *const&#160;</td>
          <td class="paramname"><em>point_b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tests whether 2 points are equal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">point_a</td><td>Pointer to the first point </td></tr>
    <tr><td class="paramname">point_b</td><td>Pointer to the second point </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if both points are equal, <code>false</code> if not. </dd></dl>

</div>
</div>
<a class="anchor" id="gad714d5d1dd0509196d8aadbdba2ac510"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void grect_align </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___graphics_types.html#struct_g_rect">GRect</a> *&#160;</td>
          <td class="paramname"><em>rect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___graphics_types.html#struct_g_rect">GRect</a> *&#160;</td>
          <td class="paramname"><em>inside_rect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___graphics_types.html#gac8aa0eb3d3065fde8d2d6f282fa47f6a">GAlign</a>&#160;</td>
          <td class="paramname"><em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>clip</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Aligns one rectangle within another rectangle, using an alignment parameter. The relative coordinate systems of both rectangles are assumed to be the same. When clip is true, <code>rect</code> is also clipped by the constraint. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rect</td><td>The rectangle to align (in place) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rect</td><td>The aligned and optionally clipped rectangle </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">inside_rect</td><td>The rectangle in which to align <code>rect</code> </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">alignment</td><td>Determines the alignment of <code>rect</code> within <code>inside_rect</code> by specifying what edges of should overlap. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">clip</td><td>Determines whether <code>rect</code> should be trimmed using the edges of <code>inside_rect</code> in case <code>rect</code> extends outside of the area that <code>inside_rect</code> covers after the alignment. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae3a0a9c97927d0a72f3c5d8340e950fd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___graphics_types.html#struct_g_point">GPoint</a> grect_center_point </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___graphics_types.html#struct_g_rect">GRect</a> *&#160;</td>
          <td class="paramname"><em>rect</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience function to compute the center-point of a given rectangle. This is equal to <code>(rect-&gt;x + rect-&gt;width / 2, rect-&gt;y + rect-&gt;height / 2)</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rect</td><td>The rectangle for which to calculate the center point. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The point at the center of <code>rect</code> </dd></dl>

</div>
</div>
<a class="anchor" id="ga0be9e99bf608e20c4ce33c48a859efa6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void grect_clip </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___graphics_types.html#struct_g_rect">GRect</a> *const&#160;</td>
          <td class="paramname"><em>rect_to_clip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___graphics_types.html#struct_g_rect">GRect</a> *const&#160;</td>
          <td class="paramname"><em>rect_clipper</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trim one rectangle using the edges of a second rectangle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rect_to_clip</td><td>The rectangle that needs to be clipped (in place). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rect_to_clip</td><td>The clipped rectangle. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">rect_clipper</td><td>The rectangle of which the edges will serve as "scissors" in order to trim <code>rect_to_clip</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga8952ac950ca4ec1195106e7b208a82c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool grect_contains_point </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___graphics_types.html#struct_g_rect">GRect</a> *&#160;</td>
          <td class="paramname"><em>rect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___graphics_types.html#struct_g_point">GPoint</a> *&#160;</td>
          <td class="paramname"><em>point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tests whether a rectangle contains a point. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rect</td><td>The rectangle </td></tr>
    <tr><td class="paramname">point</td><td>The point </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the rectangle contains the point, or <code>false</code> if it does not. </dd></dl>

</div>
</div>
<a class="anchor" id="ga45ade8bcee6668a5b9fc3a5dc2adbb4c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___graphics_types.html#struct_g_rect">GRect</a> grect_crop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___graphics_types.html#struct_g_rect">GRect</a>&#160;</td>
          <td class="paramname"><em>rect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int32_t&#160;</td>
          <td class="paramname"><em>crop_size_px</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reduce the width and height of a rectangle by insetting each of the edges with a fixed inset. The returned rectangle will be centered relative to the input rectangle. </p>
<dl class="section note"><dt>Note</dt><dd>The function will trip an assertion if the crop yields a rectangle with negative width or height. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rect</td><td>The rectangle that will be inset </td></tr>
    <tr><td class="paramname">crop_size_px</td><td>The inset by which each of the rectangle will be inset. A positive inset value results in a smaller rectangle, while negative inset value results in a larger rectangle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The cropped rectangle. </dd></dl>

</div>
</div>
<a class="anchor" id="gac4bfb1da25ab4fec1a84ffbc50a40bb5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool grect_equal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___graphics_types.html#struct_g_rect">GRect</a> *const&#160;</td>
          <td class="paramname"><em>rect_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___graphics_types.html#struct_g_rect">GRect</a> *const&#160;</td>
          <td class="paramname"><em>rect_b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tests whether 2 rectangles are equal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rect_a</td><td>Pointer to the first rectangle </td></tr>
    <tr><td class="paramname">rect_b</td><td>Pointer to the second rectangle </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if both rectangles are equal, <code>false</code> if not. </dd></dl>

</div>
</div>
<a class="anchor" id="gabbece2417a145e398e6c1ce512203150"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool grect_is_empty </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___graphics_types.html#struct_g_rect">GRect</a> *const&#160;</td>
          <td class="paramname"><em>rect</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tests whether the size of the rectangle is (0, 0). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rect</td><td>Pointer to the rectangle </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the rectangle its size is (0, 0), or <code>false</code> if not. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If the width and/or height of a rectangle is negative, this function will return <code>true</code>! </dd></dl>

</div>
</div>
<a class="anchor" id="ga6fcd8b24daede67494e49fa4803760a8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void grect_standardize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___graphics_types.html#struct_g_rect">GRect</a> *&#160;</td>
          <td class="paramname"><em>rect</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a rectangle's values so that the components of its size (width and/or height) are both positive. In the width and/or height are negative, the origin will offset, so that the final rectangle overlaps with the original. For example, a <a class="el" href="group___graphics_types.html#struct_g_rect" title="Represents a rectangle and defining it using the origin of the upper-lefthand corner and its size...">GRect</a> with size (-10, -5) and origin (20, 20), will be standardized to size (10, 5) and origin (10, 15). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rect</td><td>The rectangle to convert. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rect</td><td>The standardized rectangle. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga182655c93aaff5c2df45aba496c64b7e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool gsize_equal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___graphics_types.html#struct_g_size">GSize</a> *&#160;</td>
          <td class="paramname"><em>size_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___graphics_types.html#struct_g_size">GSize</a> *&#160;</td>
          <td class="paramname"><em>size_b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tests whether 2 sizes are equal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size_a</td><td>Pointer to the first size </td></tr>
    <tr><td class="paramname">size_b</td><td>Pointer to the second size </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if both sizes are equal, <code>false</code> if not. </dd></dl>

</div>
</div>
<hr/><h2 class="groupheader">Data Structure Documentation</h2>
<a name="struct_g_point" id="struct_g_point"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct GPoint</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Represents a point in a 2-dimensional coordinate system. </p>
<dl class="section note"><dt>Note</dt><dd>Conventionally, the origin of Pebble's 2D coordinate system is in the upper, lefthand corner its x-axis extends to the right and its y-axis extends to the bottom of the screen. </dd></dl>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a1f1a9ce775dde3448a265dc36b2024f4"></a>int16_t</td>
<td class="fieldname">
x</td>
<td class="fielddoc">
The x-coordinate. </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a94afc39fa39df567b9e78702d1f07b3e"></a>int16_t</td>
<td class="fieldname">
y</td>
<td class="fielddoc">
The y-coordinate. </td></tr>
</table>

</div>
</div>
<a name="struct_g_rect" id="struct_g_rect"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct GRect</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Represents a rectangle and defining it using the origin of the upper-lefthand corner and its size. </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a28af4b04e081517f4f546c4af5b44612"></a><a class="el" href="group___graphics_types.html#struct_g_point">GPoint</a></td>
<td class="fieldname">
origin</td>
<td class="fielddoc">
The coordinate of the upper-lefthand corner point of the rectangle. </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="acd904b1a13b264f257827a295d2d208e"></a><a class="el" href="group___graphics_types.html#struct_g_size">GSize</a></td>
<td class="fieldname">
size</td>
<td class="fielddoc">
The size of the rectangle. </td></tr>
</table>

</div>
</div>
<a name="struct_g_size" id="struct_g_size"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct GSize</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Represents a 2-dimensional size. </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a class="anchor" id="acb2d7af62d2615276d4776aa3a2ea0ca"></a>int16_t</td>
<td class="fieldname">
h</td>
<td class="fielddoc">
The height. </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="ab4b00bc79cc43d5554d19fd273fe37e0"></a>int16_t</td>
<td class="fieldname">
w</td>
<td class="fielddoc">
The width. </td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="gac8aa0eb3d3065fde8d2d6f282fa47f6a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___graphics_types.html#gac8aa0eb3d3065fde8d2d6f282fa47f6a">GAlign</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Values to specify how two things should be aligned relative to each other. </p>
<div class="image">
<img src="galign.png" alt="galign.png"/>
<div class="caption">
.</div></div>
 </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group___bitmap_layer.html#ga4c1765f9330890641c4c09ba7e894894">bitmap_layer_set_alignment()</a> </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="ggac8aa0eb3d3065fde8d2d6f282fa47f6aa51bd2083cb00987d9e770436985642b2"></a>GAlignCenter</em>&nbsp;</td><td class="fielddoc">
<p>Align by centering. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggac8aa0eb3d3065fde8d2d6f282fa47f6aae47b90e410e218b1035083f7d6df8371"></a>GAlignTopLeft</em>&nbsp;</td><td class="fielddoc">
<p>Align by making the top edges overlap and left edges overlap. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggac8aa0eb3d3065fde8d2d6f282fa47f6aaa6582295979f7c0661f6b5c686a5a606"></a>GAlignTopRight</em>&nbsp;</td><td class="fielddoc">
<p>Align by making the top edges overlap and left edges overlap. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggac8aa0eb3d3065fde8d2d6f282fa47f6aa2791f2177d74ec6baf029a8e25f731d9"></a>GAlignTop</em>&nbsp;</td><td class="fielddoc">
<p>Align by making the top edges overlap and centered horizontally. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggac8aa0eb3d3065fde8d2d6f282fa47f6aab6fc58bfb9c295f87bee0e6d77b4d683"></a>GAlignLeft</em>&nbsp;</td><td class="fielddoc">
<p>Align by making the left edges overlap and centered vertically. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggac8aa0eb3d3065fde8d2d6f282fa47f6aa0e09ed4f51fd1f8b81205a61405b6eeb"></a>GAlignBottom</em>&nbsp;</td><td class="fielddoc">
<p>Align by making the bottom edges overlap and centered horizontally. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggac8aa0eb3d3065fde8d2d6f282fa47f6aa91754028af85b5079e59025bc13bc021"></a>GAlignRight</em>&nbsp;</td><td class="fielddoc">
<p>Align by making the right edges overlap and centered vertically. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggac8aa0eb3d3065fde8d2d6f282fa47f6aab7802cc31f96f00cc88cc9d9fd3d8467"></a>GAlignBottomRight</em>&nbsp;</td><td class="fielddoc">
<p>Align by making the bottom edges overlap and right edges overlap. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggac8aa0eb3d3065fde8d2d6f282fa47f6aa0d082bc1a280106ce0c8ce60508ed44d"></a>GAlignBottomLeft</em>&nbsp;</td><td class="fielddoc">
<p>Align by making the bottom edges overlap and left edges overlap. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga5c29b6b52478182a01ec4863de80ebfa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___graphics_types.html#ga5c29b6b52478182a01ec4863de80ebfa">GBitmapFormat</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The format of a GBitmap can either be 1-bit or 8-bit. </p>

</div>
</div>
<a class="anchor" id="ga0d021422bd90a2a49e6c8d848e6d556f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___graphics_types.html#ga0d021422bd90a2a49e6c8d848e6d556f">GCompOp</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Values to specify how the source image should be composited onto the destination image. </p>
<p>There is no notion of "transparency" in the graphics system. However, the effect of transparency can be created by masking and using compositing modes. </p>
<div class="image">
<img src="compops.png" alt="compops.png"/>
</div>
<p> Contrived example of how the different compositing modes affect drawing. Often, the "destination image" is the render buffer and thus contains the image of what has been drawn before or "underneath". </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group___bitmap_layer.html#ga7bc761ca8227881c5853cbc0e279385e">bitmap_layer_set_compositing_mode()</a> </dd>
<dd>
<a class="el" href="group___graphics_context.html#ga64bc6cc5f86dabcd4b3cfa9fcffa328c">graphics_context_set_compositing_mode()</a> </dd>
<dd>
<a class="el" href="group___drawing.html#ga2df0bc47f542ea60500d3070670725f9">graphics_draw_bitmap_in_rect()</a> </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="gga0d021422bd90a2a49e6c8d848e6d556fa3d668fac5e660241746c082d7155e059"></a>GCompOpAssign</em>&nbsp;</td><td class="fielddoc">
<p>Assign the pixel values of the source image to the destination pixels, effectively replacing the previous values for those pixels. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga0d021422bd90a2a49e6c8d848e6d556fa1ee43eff5811f9066ee8a94498e7d828"></a>GCompOpAssignInverted</em>&nbsp;</td><td class="fielddoc">
<p>Assign the <b>inverted</b> pixel values of the source image to the destination pixels, effectively replacing the previous values for those pixels. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga0d021422bd90a2a49e6c8d848e6d556fa30d689e91f2ce16dd949b4076fb76ce4"></a>GCompOpOr</em>&nbsp;</td><td class="fielddoc">
<p>Use the boolean operator <code>OR</code> to composite the source and destination pixels. The visual result of this compositing mode is the source's white pixels are painted onto the destination and the source's black pixels are treated as clear. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga0d021422bd90a2a49e6c8d848e6d556fa0859125379c8687a92843a6db44fb7a6"></a>GCompOpAnd</em>&nbsp;</td><td class="fielddoc">
<p>Use the boolean operator <code>AND</code> to composite the source and destination pixels. The visual result of this compositing mode is the source's black pixels are painted onto the destination and the source's white pixels are treated as clear. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga0d021422bd90a2a49e6c8d848e6d556faba6dadf20ebce8ba4c25ecf3c9a39142"></a>GCompOpClear</em>&nbsp;</td><td class="fielddoc">
<p>Clears the bits in the destination image, using the source image as mask. The visual result of this compositing mode is that for the parts where the source image is white, the destination image will be painted black. Other parts will be left untouched. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga0d021422bd90a2a49e6c8d848e6d556fa3ca84b5c70798643a3bd07b263c47fe6"></a>GCompOpSet</em>&nbsp;</td><td class="fielddoc">
<p>Sets the bits in the destination image, using the source image as mask. The visual result of this compositing mode is that for the parts where the source image is black, the destination image will be painted white. Other parts will be left untouched. When drawing color PNGs, this mode will be required to apply any transparency. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="ga8cb8f728e01e63674935d7601f438841"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define COLOR_FALLBACK</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">color, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">bw&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;(color)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience macro allowing use of a fallback color for black and white platforms. On color platforms this defaults to color. </p>

</div>
</div>
<a class="anchor" id="ga3c778a69b007e2dd2aeb2a8253d2a3ad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define GColorFromHEX</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">v)</td><td></td>
          <td>&#160;&#160;&#160;<a class="el" href="group___graphics_types.html#ga5526fda29291b139ceb4c736f7aa61e4">GColorFromRGB</a>(((v) &gt;&gt; 16) &amp; 0xff, ((v) &gt;&gt; 8) &amp; 0xff, ((v) &amp; 0xff))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert hex integer to GColor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Integer hex value (e.g. 0x64ff46) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>GColor created from the hex value </dd></dl>

</div>
</div>
<a class="anchor" id="ga5526fda29291b139ceb4c736f7aa61e4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define GColorFromRGB</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">red, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">green, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">blue&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="group___graphics_types.html#gaa7922ac35d2b7fd40547083eed4ed757">GColorFromRGBA</a>(red, green, blue, 255)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert RGB to GColor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">red</td><td>Red value from 0 - 255 </td></tr>
    <tr><td class="paramname">green</td><td>Green value from 0 - 255 </td></tr>
    <tr><td class="paramname">blue</td><td>Blue value from 0 - 255 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>GColor created from the RGB values </dd></dl>

</div>
</div>
<a class="anchor" id="gaa7922ac35d2b7fd40547083eed4ed757"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define GColorFromRGBA</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">red, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">green, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">blue, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">alpha&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">((GColor8){ \</div>
<div class="line">  .a = (uint8_t)(alpha) &gt;&gt; 6, \</div>
<div class="line">  .r = (uint8_t)(red) &gt;&gt; 6, \</div>
<div class="line">  .g = (uint8_t)(green) &gt;&gt; 6, \</div>
<div class="line">  .b = (uint8_t)(blue) &gt;&gt; 6, \</div>
<div class="line">  })</div>
</div><!-- fragment -->
<p>Convert RGBA to GColor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">red</td><td>Red value from 0 - 255 </td></tr>
    <tr><td class="paramname">green</td><td>Green value from 0 - 255 </td></tr>
    <tr><td class="paramname">blue</td><td>Blue value from 0 - 255 </td></tr>
    <tr><td class="paramname">alpha</td><td>Alpha value from 0 - 255 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>GColor created from the RGB values </dd></dl>

</div>
</div>
<a class="anchor" id="gabf9cee451faac8ad07157b775b951699"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="group___graphics_types.html#struct_g_point">GPoint</a></td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">y&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;((<a class="el" href="group___graphics_types.html#struct_g_point">GPoint</a>){(x), (y)})</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience macro to make a <a class="el" href="group___graphics_types.html#struct_g_point" title="Represents a point in a 2-dimensional coordinate system. ">GPoint</a>. </p>

</div>
</div>
<a class="anchor" id="ga24192f6809de17d816671a1d6a7b59b5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define GPointZero&#160;&#160;&#160;<a class="el" href="group___graphics_types.html#struct_g_point">GPoint</a>(0, 0)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience macro to make a <a class="el" href="group___graphics_types.html#struct_g_point" title="Represents a point in a 2-dimensional coordinate system. ">GPoint</a> at (0, 0). </p>

</div>
</div>
<a class="anchor" id="ga98a870072d31f765cbfaebe222d85f6e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="group___graphics_types.html#struct_g_rect">GRect</a></td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">y, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">w, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">h&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;((<a class="el" href="group___graphics_types.html#struct_g_rect">GRect</a>){{(x), (y)}, {(w), (h)}})</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience macro to make a <a class="el" href="group___graphics_types.html#struct_g_rect" title="Represents a rectangle and defining it using the origin of the upper-lefthand corner and its size...">GRect</a>. </p>

</div>
</div>
<a class="anchor" id="ga1d67ac54b909f89dfd99e52eb1a7c0bc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define GRectZero&#160;&#160;&#160;<a class="el" href="group___graphics_types.html#struct_g_rect">GRect</a>(0, 0, 0, 0)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience macro to make a <a class="el" href="group___graphics_types.html#struct_g_rect" title="Represents a rectangle and defining it using the origin of the upper-lefthand corner and its size...">GRect</a> of ((0, 0), (0, 0)). </p>

</div>
</div>
<a class="anchor" id="ga71761014e71575ac39edc38709cc048b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="group___graphics_types.html#struct_g_size">GSize</a></td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">w, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">h&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;((<a class="el" href="group___graphics_types.html#struct_g_size">GSize</a>){(w), (h)})</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience macro to make a <a class="el" href="group___graphics_types.html#struct_g_size" title="Represents a 2-dimensional size. ">GSize</a>. </p>

</div>
</div>
<a class="anchor" id="ga7b5e385c855d8c9ad59209816f62b808"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define GSizeZero&#160;&#160;&#160;<a class="el" href="group___graphics_types.html#struct_g_size">GSize</a>(0, 0)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience macro to make a <a class="el" href="group___graphics_types.html#struct_g_size" title="Represents a 2-dimensional size. ">GSize</a> of (0, 0). </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
</div>
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Fri Mar 20 2015 01:01:38 for Pebble SDK by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.4 </li>
  </ul>
</div>
</body>
</html>
